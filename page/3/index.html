<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-Java/多线程/正确理解ThreadLocal" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/20/Java/多线程/正确理解ThreadLocal/" class="article-date">
  <time datetime="2017-03-20T12:06:13.000Z" itemprop="datePublished">2017-03-20</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/20/Java/多线程/正确理解ThreadLocal/">正确理解ThreadLocal</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="正确理解ThreadLocal"><a href="#正确理解ThreadLocal" class="headerlink" title="正确理解ThreadLocal"></a>正确理解ThreadLocal</h1><p>首先，ThreadLocal 不是用来解决共享对象的多线程访问问题的，一般情况下，通过ThreadLocal.set() 到线程中的对象是该线程自己使用的对象，其他线程是不需要访问的，也访问不到的。各个线程中访问的是不同的对象。 </p>
<p>另外，说ThreadLocal使得各线程能够保持各自独立的一个对象，并不是通过ThreadLocal.set()来实现的，而是通过每个线程中的new 对象 的操作来创建的对象，每个线程创建一个，不是什么对象的拷贝或副本。通过ThreadLocal.set()将这个新创建的对象的引用保存到各线程的自己的一个map中，每个线程都有这样一个map，执行ThreadLocal.get()时，各线程从自己的map中取出放进去的对象，因此取出来的是各自自己线程中的对象，ThreadLocal实例是作为map的key来使用的。 </p>
<p>如果ThreadLocal.set()进去的东西本来就是多个线程共享的同一个对象，那么多个线程的ThreadLocal.get()取得的还是这个共享对象本身，还是有并发访问问题。 </p>
        
          <p class="article-more-link">
            <a href="/2017/03/20/Java/多线程/正确理解ThreadLocal/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/03/20/Java/多线程/正确理解ThreadLocal/" data-id="cjtf6o96u00ec0fc5pb6thp6x" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/多线程/">多线程</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Java/多线程与并发/正确理解ThreadLocal" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/20/Java/多线程与并发/正确理解ThreadLocal/" class="article-date">
  <time datetime="2017-03-20T12:06:13.000Z" itemprop="datePublished">2017-03-20</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/20/Java/多线程与并发/正确理解ThreadLocal/">正确理解ThreadLocal</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="正确理解ThreadLocal"><a href="#正确理解ThreadLocal" class="headerlink" title="正确理解ThreadLocal"></a>正确理解ThreadLocal</h1><p>首先，ThreadLocal 不是用来解决共享对象的多线程访问问题的！！！<br>JDK源码中这样描述：</p>
<blockquote>
<p>This class provides thread-local variables. These variables differ from<br>their normal counterparts in that each thread that accesses one (via its<br>{@code get} or {@code set} method) has its own, independently initialized<br>copy of the variable. {@code ThreadLocal} instances are typically private<br>static fields in classes that wish to associate state with a thread (e.g.,<br>a user ID or Transaction ID).</p>
</blockquote>
<p>翻译为：</p>
<blockquote>
<p>ThreadLocal类用来提供线程内部的局部变量。这种变量在多线程环境下访问(通过get或set方法访问)时能保证各个线程里的变量相对独立于其他线程内的变量。ThreadLocal实例通常来说都是private static类型的，用于关联线程和线程的上下文。</p>
</blockquote>
<p>另外，说ThreadLocal使得各线程能够保持各自独立的一个对象，并不是通过ThreadLocal.set()来实现的，而是通过每个线程中的new 对象的操作来创建的对象，每个线程创建一个，不是什么对象的拷贝或副本。通过ThreadLocal.set()将这个新创建的对象的引用保存到各线程的自己的一个map中，每个线程都有这样一个map，执行ThreadLocal.get()时，各线程从自己的map中取出放进去的对象，因此取出来的是各自自己线程中的对象，ThreadLocal实例是作为map的key来使用的。 </p>
<p>如果ThreadLocal.set()进去的东西本来就是多个线程共享的同一个对象，那么多个线程的ThreadLocal.get()取得的还是这个共享对象本身，还是有并发访问问题。 </p>
        
          <p class="article-more-link">
            <a href="/2017/03/20/Java/多线程与并发/正确理解ThreadLocal/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/03/20/Java/多线程与并发/正确理解ThreadLocal/" data-id="cjtf6o96x00el0fc5508ktdwt" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/多线程/">多线程</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Job/面经/面经--阿里" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/18/Job/面经/面经--阿里/" class="article-date">
  <time datetime="2017-03-18T08:06:13.000Z" itemprop="datePublished">2017-03-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Job/">Job</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/18/Job/面经/面经--阿里/">面经--阿里</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>#面经–阿里</p>
<h2 id="阿里一面—基础，语言无关"><a href="#阿里一面—基础，语言无关" class="headerlink" title="阿里一面—基础，语言无关"></a>阿里一面—基础，语言无关</h2><h3 id="1-介绍项目"><a href="#1-介绍项目" class="headerlink" title="1.介绍项目"></a>1.介绍项目</h3><p>搜索引擎项目（Nutch+Lucene）</p>
<h3 id="2-Nutch（加强细节）"><a href="#2-Nutch（加强细节）" class="headerlink" title="2.Nutch（加强细节）"></a>2.Nutch（加强细节）</h3><p>优化实现细节<br>缓存存储结构如何实现</p>
<h3 id="3-Lucene（需要加强）"><a href="#3-Lucene（需要加强）" class="headerlink" title="3.Lucene（需要加强）"></a>3.Lucene（需要加强）</h3><ul>
<li>什么是索引<br>数据库索引，是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据。索引的实现通常使用B树及其变种B+树。</li>
<li><p>如何实现索引</p>
</li>
<li><p>Lucene索引结构</p>
</li>
</ul>
<ul>
<li>倒排索引<br>一种索引方法，被用来存储在全文搜索下某个单词在一个文档或者一组文档中的存储位置的映射。它是文档检索系统中最常用的数据结构。通过倒排索引，可以根据单词快速获取包含这个单词的文档列表。倒排索引主要由两个部分组成：“单词词典”和“倒排文件”。</li>
</ul>
        
          <p class="article-more-link">
            <a href="/2017/03/18/Job/面经/面经--阿里/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/03/18/Job/面经/面经--阿里/" data-id="cjtf6o96f00do0fc5scephq56" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/面经/">面经</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Python/Pyspider Bug总结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/17/Python/Pyspider Bug总结/" class="article-date">
  <time datetime="2017-03-17T10:06:13.000Z" itemprop="datePublished">2017-03-17</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Python/">Python</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/17/Python/Pyspider Bug总结/">Pyspider Bug总结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Pyspider-Bug总结"><a href="#Pyspider-Bug总结" class="headerlink" title="Pyspider Bug总结"></a>Pyspider Bug总结</h1><p>启动报错</p>
<ol>
<li><p>“message_queue”: “redis://127.0.0.1:6379/15” 报错ImportError: No module name redis<br>Python需要安装redis库才能支持<br><code>pip install redis</code>后解决</p>
</li>
<li><p>启动 pyspider 发现有 Could not create web server listening on port 25555 报错</p>
</li>
</ol>
<p><code>lsof -i:port</code>查询占用端口的pid<br>tcp 0 0 0.0.0.0:25555 0.0.0.0:* LISTEN 18326/phantomjs<br>原来phantomjs 在后台已经启动<br>kill 相应进程再启动 pyspider 错误消失</p>
        
          <p class="article-more-link">
            <a href="/2017/03/17/Python/Pyspider Bug总结/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/03/17/Python/Pyspider Bug总结/" data-id="cjtf6o92e003j0fc5sr989iex" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python/">Python</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Python/MySQLdb 遇到的问题" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/17/Python/MySQLdb 遇到的问题/" class="article-date">
  <time datetime="2017-03-17T02:06:13.000Z" itemprop="datePublished">2017-03-17</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Python/">Python</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/17/Python/MySQLdb 遇到的问题/">MySQLdb 遇到的问题</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="MySQLdb-遇到的问题"><a href="#MySQLdb-遇到的问题" class="headerlink" title="MySQLdb 遇到的问题"></a>MySQLdb 遇到的问题</h1><p>爬取得知乎想存入数据库，安装了MySQLdb后遇到了问题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import MySQLdb</span><br><span class="line">import random</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    db = MySQLdb.connect(&apos;localhost&apos;, &apos;root&apos;, &apos;123456&apos;, &apos;wenda&apos;, charset=&apos;utf8&apos;)</span><br><span class="line">    try:</span><br><span class="line">        cursor = db.cursor()</span><br><span class="line">        sql = &apos;insert into question(title, content, user_id, created_date, comment_count) values (&quot;xxx&quot;, &quot;xxx&quot;, 1, now(), 0)&apos;</span><br><span class="line">        cursor.execute(sql)</span><br><span class="line">        qid = cursor.lastrowid</span><br><span class="line">        db.commit()</span><br><span class="line">        print qid</span><br><span class="line">    except Exception, e:</span><br><span class="line">        print e</span><br><span class="line">        db.rollback()</span><br><span class="line">    db.close()</span><br></pre></td></tr></table></figure>
<p>运行报错<br>
        
          </p><p class="article-more-link">
            <a href="/2017/03/17/Python/MySQLdb 遇到的问题/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/03/17/Python/MySQLdb 遇到的问题/" data-id="cjtf6o92c003d0fc57y0blqks" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python/">Python</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Job/面试笔记--Java多线程与并发" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/16/Job/面试笔记--Java多线程与并发/" class="article-date">
  <time datetime="2017-03-16T06:33:34.000Z" itemprop="datePublished">2017-03-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Job/">Job</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/16/Job/面试笔记--Java多线程与并发/">面试笔记--Java多线程与并发</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="面试笔记–Java多线程与并发"><a href="#面试笔记–Java多线程与并发" class="headerlink" title="面试笔记–Java多线程与并发"></a>面试笔记–Java多线程与并发</h1>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/03/16/Job/面试笔记--Java多线程与并发/" data-id="cjtf6o91u00290fc5k62cch9x" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/面试笔记/">面试笔记</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Job/2017-03-26" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/15/Job/2017-03-26/" class="article-date">
  <time datetime="2017-03-15T06:33:34.000Z" itemprop="datePublished">2017-03-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Job/">Job</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/15/Job/2017-03-26/">面试笔记--大数据算法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>大数据的解法无非那么几种，常见的就是hash和bitmap</p>
<h2 id="10亿个QQ号，让我找出一个QQ号是不是在其中，时间复杂度要求O-1"><a href="#10亿个QQ号，让我找出一个QQ号是不是在其中，时间复杂度要求O-1" class="headerlink" title="10亿个QQ号，让我找出一个QQ号是不是在其中，时间复杂度要求O(1)"></a>10亿个QQ号，让我找出一个QQ号是不是在其中，时间复杂度要求O(1)</h2><p>用bitmap来做这个问题。首先对数据进行预处理。定义10亿bit位个int.在32位计算机下，一个int是32位，10亿位的话，就需要10亿除以32个int整数。大概有很多个。第一个int标记0-31这个数字范围的QQ号存不存在，比如说0000001这个QQ号，我就把第一个int的第1位置1。第二个int能够标记32-63这个范围的QQ存不存在，以此类推。把这10亿个QQ号预处理一遍。然后计算你给我的这个QQ号，它是在哪个int里面，然后找到相应的数据位，看是1还是0，就能在O(1)的时间里找到</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/03/15/Job/2017-03-26/" data-id="cjtf6o91r00220fc5ct0vq5gw" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/面试笔记/">面试笔记</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Job/面试笔记--大数据算法" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/15/Job/面试笔记--大数据算法/" class="article-date">
  <time datetime="2017-03-15T06:33:34.000Z" itemprop="datePublished">2017-03-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Job/">Job</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/15/Job/面试笔记--大数据算法/">面试笔记--大数据算法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="面试笔记–海量数据题目处理总结"><a href="#面试笔记–海量数据题目处理总结" class="headerlink" title="面试笔记–海量数据题目处理总结"></a>面试笔记–海量数据题目处理总结</h1><h2 id="何谓海量数据处理？"><a href="#何谓海量数据处理？" class="headerlink" title="何谓海量数据处理？"></a>何谓海量数据处理？</h2><p>所谓海量数据处理，无非就是基于海量数据上的存储、处理、操作。何谓海量，就是数据量太大，所以导致要么是无法在较短时间内迅速解决，要么是数据太大，导致无法一次性装入内存。</p>
<p>那解决办法呢?针对时间，我们可以采用巧妙的算法搭配合适的数据结构，如Bloom filter/Hash/bit-map/堆/数据库或倒排索引/trie树，针对空间，无非就一个办法：大而化小，分而治之（hash映射），你不是说规模太大嘛，那简单啊，就把规模大化为规模小的，各个击破不就完了嘛。</p>
<p>至于所谓的单机及集群问题，通俗点来讲，单机就是处理装载数据的机器有限(只要考虑cpu，内存，硬盘的数据交互)，而集群，机器有多辆，适合分布式处理，并行计算(更多考虑节点和节点间的数据交互)。</p>
<h2 id="海量数据处理的方法"><a href="#海量数据处理的方法" class="headerlink" title="海量数据处理的方法"></a>海量数据处理的方法</h2><p>处理海量数据问题，无非就是 6 种方法：</p>
<h3 id="分而治之-hash映射-hash统计-堆-快速-归并排序；"><a href="#分而治之-hash映射-hash统计-堆-快速-归并排序；" class="headerlink" title="分而治之/hash映射 + hash统计 + 堆/快速/归并排序；"></a>分而治之/hash映射 + hash统计 + 堆/快速/归并排序；</h3><ol>
<li>分而治之/hash映射：针对数据太大，内存受限，只能把大文件化成(取模映射)小文件</li>
<li>hash_map统计：当大文件转化了小文件，那么我们便可以采用常规的hash_map(key，value)来进行频率统计。</li>
<li>堆/快速排序：统计完了之后，便进行排序(可采取堆排序)，得到次数最多的key。</li>
</ol>
<h3 id="多层划分"><a href="#多层划分" class="headerlink" title="多层划分"></a>多层划分</h3><p>多层划分—-其实本质上还是分而治之的思想，重在“分”的技巧上！<br>适用范围：第k大，中位数，不重复或重复的数字<br>基本原理及要点：因为元素范围很大，不能利用直接寻址表，所以通过多次划分，逐步确定范围，然后最后在一个可以接受的范围内进行。</p>
<h3 id="Bloom-filter-Bitmap"><a href="#Bloom-filter-Bitmap" class="headerlink" title="Bloom filter/Bitmap"></a>Bloom filter/Bitmap</h3><h4 id="Bloom-filter"><a href="#Bloom-filter" class="headerlink" title="Bloom filter"></a>Bloom filter</h4><p>适用范围：可以用来实现数据字典，进行数据的判重，或者集合求交集<br>基本原理：当一个元素被加入集合时，通过K个Hash函数将这个元素映射成一个位阵列（Bit array）中的K个点，把它们置为1。检索时，我们只要看看这些点是不是都是1就（大约）知道集合中有没有它了：如果这些点有任何一个0，则被检索元素一定不在；如果都是1，则被检索元素很可能在。</p>
<blockquote>
<p>Bloom Filter的这种高效是有一定代价的：在判断一个元素是否属于某个集合时，有可能会把不属于这个集合的元素误认为属于这个集合（false positive）。因此，Bloom Filter不适合那些“零错误”的应用场合。而在能容忍低错误率的应用场合下，Bloom Filter通过极少的错误换取了存储空间的极大节省。</p>
</blockquote>
<h4 id="Bitmap"><a href="#Bitmap" class="headerlink" title="Bitmap"></a>Bitmap</h4><p>Bit-map就是用一个bit位来标记某个元素对应的Value， 而Key即是该元素。由于采用了Bit为单位来表示某个元素是否存在，因此在存储空间方面，可以大大节省。</p>
<blockquote>
<p>Bitmap排序方法<br>第一步，将所有的位都置为0，从而将集合初始化为空。<br>第二步，通过读入文件中的每个整数来建立集合，将每个对应的位都置为1。<br>第三步，检验每一位，如果该位为1，就输出对应的整数。</p>
</blockquote>
<blockquote>
<p>Bloom filter可以看做是对bit-map的扩展</p>
</blockquote>
<h3 id="Trie树-数据库-倒排索引"><a href="#Trie树-数据库-倒排索引" class="headerlink" title="Trie树/数据库/倒排索引"></a>Trie树/数据库/倒排索引</h3><h4 id="Trie树"><a href="#Trie树" class="headerlink" title="Trie树"></a>Trie树</h4><p>适用范围：数据量大，重复多，但是数据种类小可以放入内存<br>基本原理及要点：实现方式，节点孩子的表示方式<br>扩展：压缩实现。</p>
<h4 id="数据库索引"><a href="#数据库索引" class="headerlink" title="数据库索引"></a>数据库索引</h4><p>适用范围：大数据量的增删改查<br>基本原理及要点：利用数据的设计实现方法，对海量数据的增删改查进行处理。</p>
<h4 id="倒排索引-Inverted-index"><a href="#倒排索引-Inverted-index" class="headerlink" title="倒排索引(Inverted index)"></a>倒排索引(Inverted index)</h4><p>适用范围：搜索引擎，关键字查询<br>基本原理及要点：一种索引方法，被用来存储在全文搜索下某个单词在一个文档或者一组文档中的存储位置的映射。</p>
<h3 id="外排序"><a href="#外排序" class="headerlink" title="外排序"></a>外排序</h3><p>适用范围：大数据的排序，去重<br>基本原理及要点：外排序的归并方法，置换选择败者树原理，最优归并树</p>
<h3 id="分布式处理之Hadoop-Mapreduce"><a href="#分布式处理之Hadoop-Mapreduce" class="headerlink" title="分布式处理之Hadoop/Mapreduce"></a>分布式处理之Hadoop/Mapreduce</h3><p>MapReduce是一种计算模型，简单的说就是将大批量的工作（数据）分解（MAP）执行，然后再将结果合并成最终结果（REDUCE）。这样做的好处是可以在任务被分解后，可以通过大量机器进行并行计算，减少整个操作的时间。<br>适用范围：数据量大，但是数据种类小可以放入内存<br>基本原理及要点：将数据交给不同的机器去处理，数据划分，结果归约。</p>
<h2 id="海量数据处理题目"><a href="#海量数据处理题目" class="headerlink" title="海量数据处理题目"></a>海量数据处理题目</h2><h3 id="1-海量日志数据，提取出某日访问百度次数最多的那个IP"><a href="#1-海量日志数据，提取出某日访问百度次数最多的那个IP" class="headerlink" title="1.海量日志数据，提取出某日访问百度次数最多的那个IP"></a>1.海量日志数据，提取出某日访问百度次数最多的那个IP</h3><ol>
<li>分而治之/hash映射：针对数据太大，内存受限，只能是把大文件化成(取模映射)小文件；按照IP地址的Hash(IP)%1000值，把海量IP日志分别存储到1000个小文件中。这样，每个小文件最多包含4MB个IP地址</li>
<li>hash_map统计：当大文件转化了小文件，那么我们便可以采用常规的hash_map(ip，value)来进行频率统计。</li>
<li>堆/快速排序：统计完了之后，可以得到1024个小文件中的出现次数最多的IP，再依据常规的排序算法得到总体上出现次数最多的IP；</li>
</ol>
<blockquote>
<p>Hash取模是一种等价映射，不会存在同一个元素分散到不同小文件中的情况，即这里采用的是mod1000算法，那么相同的IP在hash取模后，只可能落在同一个文件中，不可能被分散的。因为如果两个IP相等，那么经过Hash(IP)之后的哈希值是相同的，将此哈希值取模（如模1000），必定仍然相等。</p>
</blockquote>
<h3 id="2-寻找热门查询，300万个查询字符串中统计最热门的10个查询"><a href="#2-寻找热门查询，300万个查询字符串中统计最热门的10个查询" class="headerlink" title="2.寻找热门查询，300万个查询字符串中统计最热门的10个查询"></a>2.寻找热门查询，300万个查询字符串中统计最热门的10个查询</h3><p>原题：搜索引擎会通过日志文件把用户每次检索使用的所有检索串都记录下来，每个查询串的长度为1-255字节。假设目前有一千万个记录（这些查询串的重复度比较高，虽然总数是1千万，但如果除去重复后，不超过3百万个。一个查询串的重复度越高，说明查询它的用户越多，也就是越热门），请你统计最热门的10个查询串，要求使用的内存不能超过1G。</p>
<p>数据规模大，一次处理不了，我们就需要将数据通过hash映射切分；而本题的情况属于数据量可以一次放入内存(300万个字符串假设没有重复，都是最大长度，那么最多占用内存3M*1K/4=0.75G。所以可以将所有字符串都存放在内存中进行处理)，所以只是需要一个合适的数据结构</p>
<p>所以我们在此直接读数据进行hash统计，统计后的数据只有0.75G，可以直接进行排序，而对这种TopK问题，一般是采用堆来解决。</p>
<ol>
<li>hash_map统计：先对这批海量数据预处理。具体方法是：维护一个Key为Query字串，Value为该Query出现次数的HashMap，即hashmap(Query，Value)，每次读取一个Query，如果该字串不在HashMap中，那么加入该字串，并且将Value值设为1；如果该字串在HashMap中，那么将该字串的计数加一即可。最终我们在O(N)的时间复杂度内用Hash表完成了统计；</li>
<li>堆排序：借助堆这个数据结构，找出Top K，时间复杂度为O(NlogK)。因此，维护一个K(该题目中是10)大小的小根堆，然后遍历300万的Query，分别和根元素进行对比。所以，我们最终的时间复杂度是：O（N） + N’ * O（logK），（N为1000万，N’为300万）。</li>
</ol>
<p>方案2：<br>采用trie树，关键字域存该查询串出现的次数，没有出现为0。最后用10个元素的最小推来对出现频率进行排序。</p>
<h3 id="3-有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16字节，内存限制大小是1M。返回频数最高的100个词。"><a href="#3-有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16字节，内存限制大小是1M。返回频数最高的100个词。" class="headerlink" title="3.有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16字节，内存限制大小是1M。返回频数最高的100个词。"></a>3.有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16字节，内存限制大小是1M。返回频数最高的100个词。</h3><ol>
<li>分而治之/hash映射：顺序读文件中，对于每个词x，取hash(x)%5000，然后按照该值存到5000个小文件（记为x0,x1,…x4999）中。这样每个文件大概是200k左右。如果其中的有的文件超过了1M大小，还可以按照类似的方法继续往下分，直到分解得到的小文件的大小都不超过1M。</li>
<li>hash_map统计：对每个小文件，采用trie树/hash_map等统计每个文件中出现的词以及相应的频率。</li>
<li>堆/归并排序：取出出现频率最大的100个词（可以用含100个结点的最小堆）后，再把100个词及相应的频率存入文件，这样又得到了5000个文件。最后就是把这5000个文件进行归并（类似于归并排序）的过程了。</li>
</ol>
<h3 id="4-海量数据分布在100台电脑中，想个办法高效统计出这批数据的TOP10。"><a href="#4-海量数据分布在100台电脑中，想个办法高效统计出这批数据的TOP10。" class="headerlink" title="4.海量数据分布在100台电脑中，想个办法高效统计出这批数据的TOP10。"></a>4.海量数据分布在100台电脑中，想个办法高效统计出这批数据的TOP10。</h3><p>如果每个数据元素只出现一次，而且只出现在某一台机器中，那么可以采取以下步骤统计出现次数TOP10的数据元素：</p>
<ol>
<li>如果每个数据元素只出现一次，而且只出现在某一台机器中，那么可以采取以下步骤统计出现次数TOP10的数据元素：</li>
<li>求出每台电脑上的TOP10后，然后把这100台电脑上的TOP10组合起来，共1000个数据，再利用上面类似的方法求出TOP10就可以了。</li>
</ol>
<p>但如果同一个元素重复出现在不同的电脑中,则有两种方法：</p>
<ul>
<li>遍历一遍所有数据，重新hash取摸，如此使得同一个元素只出现在单独的一台电脑中，然后采用上面所说的方法，统计每台电脑中各个元素的出现次数找出TOP10，继而组合100台电脑上的TOP10，找出最终的TOP10。</li>
<li>暴力求解：直接统计统计每台电脑中各个元素的出现次数，然后把同一个元素在不同机器中的出现次数相加，最终从所有数据中找出TOP10。</li>
</ul>
<h3 id="5-有10个文件，每个文件1G，每个文件的每一行存放的都是用户的query，每个文件的query都可能重复。要求你按照query的频度排序。"><a href="#5-有10个文件，每个文件1G，每个文件的每一行存放的都是用户的query，每个文件的query都可能重复。要求你按照query的频度排序。" class="headerlink" title="5.有10个文件，每个文件1G，每个文件的每一行存放的都是用户的query，每个文件的query都可能重复。要求你按照query的频度排序。"></a>5.有10个文件，每个文件1G，每个文件的每一行存放的都是用户的query，每个文件的query都可能重复。要求你按照query的频度排序。</h3><p>方案1：</p>
<ol>
<li>hash映射：顺序读取10个文件，按照hash(query)%10的结果将query写入到另外10个文件（记为a0,a1,..a9）中。这样新生成的文件每个的大小大约也1G（假设hash函数是随机的）。</li>
<li>hash_map统计：找一台内存在2G左右的机器，依次对用hash_map(query, query_count)来统计每个query出现的次数。注：hash_map(query,query_count)是用来统计每个query的出现次数，不是存储他们的值，出现一次，则count+1。</li>
<li>堆/快速/归并排序：利用快速/堆/归并排序按照出现次数进行排序，将排序好的query和对应的query_cout输出到文件中，这样得到了10个排好序的文件（记为）。最后，对这10个文件进行归并排序（内排序与外排序相结合）</li>
</ol>
<p>方案2：<br> 一般query的总量是有限的，只是重复的次数比较多而已，可能对于所有的query，一次性就可以加入到内存了。这样，我们就可以采用trie树/hash_map等直接来统计每个query出现的次数，然后按出现次数做快速/堆/归并排序就可以了。</p>
<p>方案3：<br>与方案1类似，但在做完hash，分成多个文件后，可以交给多个文件来处理，采用分布式的架构来处理（比如MapReduce），最后再进行合并。</p>
<h3 id="6-给定a、b两个文件，各存放50亿个url，每个url各占64字节，内存限制是4G，让你找出a、b文件共同的url？"><a href="#6-给定a、b两个文件，各存放50亿个url，每个url各占64字节，内存限制是4G，让你找出a、b文件共同的url？" class="headerlink" title="6.给定a、b两个文件，各存放50亿个url，每个url各占64字节，内存限制是4G，让你找出a、b文件共同的url？"></a>6.给定a、b两个文件，各存放50亿个url，每个url各占64字节，内存限制是4G，让你找出a、b文件共同的url？</h3><p>可以估计每个文件安的大小为5G×64=320G，远远大于内存限制的4G。所以不可能将其完全加载到内存中处理。考虑采取分而治之的方法。</p>
<p>方案1：</p>
<ol>
<li>分而治之/hash映射：遍历文件a，对每个url求取，然后根据所取得的值将url分别存储到1000个小文件（记为a0,a1,…,a999）中。这样每个小文件的大约为300M。遍历文件b，采取和a相同的方式将url分别存储到1000小文件中（记为b0,b1,…,b999）。这样处理后，所有可能相同的url都在对应的小文件（a0vsb0,a1vsb1,…,a999vsb999）中，不对应的小文件不可能有相同的url。然后我们只要求出1000对小文件中相同的url即可。</li>
<li>hash_set统计：求每对小文件中相同的url时，可以把其中一个小文件的url存储到hash_set中。然后遍历另一个小文件的每个url，看其是否在刚才构建的hash_set中，如果是，那么就是共同的url，存到文件里面就可以了。</li>
</ol>
<p>方案2：<br>如果允许有一定的错误率，可以使用Bloom filter，4G内存大概可以表示340亿bit。将其中一个文件中的url使用Bloom filter映射为这340亿bit，然后挨个读取另外一个文件的url，检查是否与Bloom filter，如果是，那么该url应该是共同的url（注意会有一定的错误率）。</p>
<h3 id="7-在2-5亿个整数中找出不重复的整数，注，内存不足以容纳这2-5亿个整数。"><a href="#7-在2-5亿个整数中找出不重复的整数，注，内存不足以容纳这2-5亿个整数。" class="headerlink" title="7.在2.5亿个整数中找出不重复的整数，注，内存不足以容纳这2.5亿个整数。"></a>7.在2.5亿个整数中找出不重复的整数，注，内存不足以容纳这2.5亿个整数。</h3><p>方案1：</p>
<ol>
<li>分而治之/hash映射</li>
<li>hashmap统计</li>
<li>找出所有value为1的key值</li>
</ol>
<p>方案2：<br>采用2-Bitmap（每个数分配2bit，00表示不存在，01表示出现一次，10表示多次，11无意义）进行，共需内存2^32 * 2 bit=1 GB内存，还可以接受。然后扫描这2.5亿个整数，查看Bitmap中相对应位，如果是00变01，01变10，10保持不变。所描完事后，查看bitmap，把对应位是01的整数输出即可。</p>
<h3 id="8-怎么在海量数据中找出重复次数最多的一个？"><a href="#8-怎么在海量数据中找出重复次数最多的一个？" class="headerlink" title="8.怎么在海量数据中找出重复次数最多的一个？"></a>8.怎么在海量数据中找出重复次数最多的一个？</h3><ol>
<li>先做hash，然后求模映射为小文件，</li>
<li>通过hashmap求出每个小文件中重复次数最多的一个，并记录重复次数。</li>
<li>然后比较所有小文件中出现最多的数，最大的就是重复次数最多</li>
</ol>
<h3 id="9-上千万或上亿数据（有重复），统计其中出现次数最多的前N个数据。"><a href="#9-上千万或上亿数据（有重复），统计其中出现次数最多的前N个数据。" class="headerlink" title="9.上千万或上亿数据（有重复），统计其中出现次数最多的前N个数据。"></a>9.上千万或上亿数据（有重复），统计其中出现次数最多的前N个数据。</h3><p>上千万或上亿的数据，现在的机器的内存应该能存下。所以考虑采用hash_map来进行统计次数。然后利用堆取出前N个出现次数最多的数据。</p>
<h3 id="10-一个文本文件，大约有一万行，每行一个词，要求统计出其中最频繁出现的前10个词，请给出思想，给出时间复杂度分析。"><a href="#10-一个文本文件，大约有一万行，每行一个词，要求统计出其中最频繁出现的前10个词，请给出思想，给出时间复杂度分析。" class="headerlink" title="10.一个文本文件，大约有一万行，每行一个词，要求统计出其中最频繁出现的前10个词，请给出思想，给出时间复杂度分析。"></a>10.一个文本文件，大约有一万行，每行一个词，要求统计出其中最频繁出现的前10个词，请给出思想，给出时间复杂度分析。</h3><p>方案1：<br>如果文件比较大，无法一次性读入内存，可以采用hash取模的方法，将大文件分解为多个小文件，对于单个小文件利用hash_map统计出每个小文件中10个最常出现的词，然后再进行归并处理，找出最终的10个最常出现的词。</p>
<p>方案2：<br>通过hash取模将大文件分解为多个小文件后，除了可以用hash_map统计出每个小文件中10个最常出现的词，也可以用trie树统计每个词出现的次数，时间复杂度是<code>O(n*le)</code>（le表示单词的平准长度），最终同样找出出现最频繁的前10个词（可用堆来实现），时间复杂度是<code>O(nlog10)</code>。</p>
<h3 id="11-1000万字符串，其中有些是重复的，需要把重复的全部去掉，保留没有重复的字符串。请怎么设计和实现？"><a href="#11-1000万字符串，其中有些是重复的，需要把重复的全部去掉，保留没有重复的字符串。请怎么设计和实现？" class="headerlink" title="11.1000万字符串，其中有些是重复的，需要把重复的全部去掉，保留没有重复的字符串。请怎么设计和实现？"></a>11.1000万字符串，其中有些是重复的，需要把重复的全部去掉，保留没有重复的字符串。请怎么设计和实现？</h3><p>方案1：<br>这题用trie树比较合适，hash_map也行。</p>
<p>方案2：<br>分而治之/hash映射 + hashmap</p>
<h3 id="12-一个文本文件，找出前10个经常出现的词，但这次文件比较长，说是上亿行或十亿行，总之无法一次读入内存，问最优解。"><a href="#12-一个文本文件，找出前10个经常出现的词，但这次文件比较长，说是上亿行或十亿行，总之无法一次读入内存，问最优解。" class="headerlink" title="12.一个文本文件，找出前10个经常出现的词，但这次文件比较长，说是上亿行或十亿行，总之无法一次读入内存，问最优解。"></a>12.一个文本文件，找出前10个经常出现的词，但这次文件比较长，说是上亿行或十亿行，总之无法一次读入内存，问最优解。</h3><ol>
<li>首先根据用hash并求模，将文件分解为多个小文件，</li>
<li>对于单个文件利用hashmap求出每个文件件中10个最常出现的词。</li>
<li>然后再进行归并处理，找出最终的10个最常出现的词。</li>
</ol>
<h3 id="13-腾讯面试题：给40亿个不重复的unsigned-int的整数，没排过序的，然后再给一个数，如何快速判断这个数是否在那40亿个数当中？"><a href="#13-腾讯面试题：给40亿个不重复的unsigned-int的整数，没排过序的，然后再给一个数，如何快速判断这个数是否在那40亿个数当中？" class="headerlink" title="13.腾讯面试题：给40亿个不重复的unsigned int的整数，没排过序的，然后再给一个数，如何快速判断这个数是否在那40亿个数当中？"></a>13.腾讯面试题：给40亿个不重复的unsigned int的整数，没排过序的，然后再给一个数，如何快速判断这个数是否在那40亿个数当中？</h3><p>方案1：<br>申请512M的内存，一个bit位代表一个unsigned int值。读入40亿个数，设置相应的bit位，读入要查询的数，查看相应bit位是否为1，为1表示存在，为0表示不存在。</p>
<h3 id="14-10亿个QQ号，让我找出一个QQ号是不是在其中，时间复杂度要求O-1"><a href="#14-10亿个QQ号，让我找出一个QQ号是不是在其中，时间复杂度要求O-1" class="headerlink" title="14.10亿个QQ号，让我找出一个QQ号是不是在其中，时间复杂度要求O(1)"></a>14.10亿个QQ号，让我找出一个QQ号是不是在其中，时间复杂度要求O(1)</h3><p>用bitmap来做这个问题。首先对数据进行预处理。定义10亿bit位个int.在32位计算机下，一个int是32位，10亿位的话，就需要10亿除以32个int整数。大概有很多个。第一个int标记0-31这个数字范围的QQ号存不存在，比如说0000001这个QQ号，我就把第一个int的第1位置1。第二个int能够标记32-63这个范围的QQ存不存在，以此类推。把这10亿个QQ号预处理一遍。然后计算你给我的这个QQ号，它是在哪个int里面，然后找到相应的数据位，看是1还是0，就能在O(1)的时间里找到</p>
<h3 id="15-移动公司需要对已经发放的所有139段的号码进行统计排序，已经发放的139号码段的文件都存放在一个文本文件中（原题是放在两个文件中），一个号码一行，现在需要将文件里的所有号码进行排序，并写入到一个新的文件中；号码可能会有很多，最多可能有一亿个不同的号码（所有的139段号码），存入文本文件中大概要占1-2G的空间；jvm最大的内存在300以内，程序要考虑程序的可执行性及效率；只能使用Java标准库，不得使用第三方工具。"><a href="#15-移动公司需要对已经发放的所有139段的号码进行统计排序，已经发放的139号码段的文件都存放在一个文本文件中（原题是放在两个文件中），一个号码一行，现在需要将文件里的所有号码进行排序，并写入到一个新的文件中；号码可能会有很多，最多可能有一亿个不同的号码（所有的139段号码），存入文本文件中大概要占1-2G的空间；jvm最大的内存在300以内，程序要考虑程序的可执行性及效率；只能使用Java标准库，不得使用第三方工具。" class="headerlink" title="15.移动公司需要对已经发放的所有139段的号码进行统计排序，已经发放的139号码段的文件都存放在一个文本文件中（原题是放在两个文件中），一个号码一行，现在需要将文件里的所有号码进行排序，并写入到一个新的文件中；号码可能会有很多，最多可能有一亿个不同的号码（所有的139段号码），存入文本文件中大概要占1.2G的空间；jvm最大的内存在300以内，程序要考虑程序的可执行性及效率；只能使用Java标准库，不得使用第三方工具。"></a>15.移动公司需要对已经发放的所有139段的号码进行统计排序，已经发放的139号码段的文件都存放在一个文本文件中（原题是放在两个文件中），一个号码一行，现在需要将文件里的所有号码进行排序，并写入到一个新的文件中；号码可能会有很多，最多可能有一亿个不同的号码（所有的139段号码），存入文本文件中大概要占1.2G的空间；jvm最大的内存在300以内，程序要考虑程序的可执行性及效率；只能使用Java标准库，不得使用第三方工具。</h3><p>方案1：</p>
<ol>
<li>顺序读取存放号码文件的中所有号码，并取139之后的八位转换为int类型；每读取号码数满一百万个（这个数据可配置）将已经读取的号码排序并存入新建的临时文件。</li>
<li>将所有生成的号码有序的临时文件合并存入结果文件。 </li>
</ol>
<blockquote>
<p>这个算法虽然解决了空间问题，但是运行效率极低，由于IO读写操作太多，加上步骤1中的排序的算法（快速排序）本来效率就不高</p>
</blockquote>
<p>方案2：bitmap<br>一个号码占一个bit，一共需要 99999999 bit ，一个int32位，所以需要312.5万个int值，即1250万Byte = 12.5M，算法如下</p>
<ol>
<li>初始化bits[capacity]； </li>
<li>顺序所有读入电话号码，并转换为int类型，修改位向量值bits[phoneNum]=1； </li>
<li>遍历bits数组，如果bits[index]=1，转换index为电话号码输出。 </li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/03/15/Job/面试笔记--大数据算法/" data-id="cjtf6o95m00b80fc5y68zrvki" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/面试笔记/">面试笔记</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-操作系统/进程间通信:线程间通信:线程与进程间通信" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/10/操作系统/进程间通信:线程间通信:线程与进程间通信/" class="article-date">
  <time datetime="2017-03-10T12:06:13.000Z" itemprop="datePublished">2017-03-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/操作系统/">操作系统</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/10/操作系统/进程间通信:线程间通信:线程与进程间通信/">进程间通信/线程间通信/线程与进程间通信</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="进程间通信-线程间通信-线程与进程间通信"><a href="#进程间通信-线程间通信-线程与进程间通信" class="headerlink" title="进程间通信/线程间通信/线程与进程间通信"></a>进程间通信/线程间通信/线程与进程间通信</h1><h2 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h2><h3 id="管道-pipe"><a href="#管道-pipe" class="headerlink" title="管道( pipe )"></a>管道( pipe )</h3><p>管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。</p>
<h3 id="有名管道-named-pipe"><a href="#有名管道-named-pipe" class="headerlink" title="有名管道 (named pipe)"></a>有名管道 (named pipe)</h3><p>有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。</p>
<h3 id="信号量-semophore"><a href="#信号量-semophore" class="headerlink" title="信号量( semophore )"></a>信号量( semophore )</h3><p>信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</p>
<h3 id="消息队列-message-queue"><a href="#消息队列-message-queue" class="headerlink" title="消息队列( message queue )"></a>消息队列( message queue )</h3><p>消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。</p>
<h3 id="信号-sinal"><a href="#信号-sinal" class="headerlink" title="信号 ( sinal )"></a>信号 ( sinal )</h3><p>信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。</p>
<h3 id="共享内存-shared-memory"><a href="#共享内存-shared-memory" class="headerlink" title="共享内存( shared memory )"></a>共享内存( shared memory )</h3><p>共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。</p>
<h3 id="套接字-socket"><a href="#套接字-socket" class="headerlink" title="套接字( socket )"></a>套接字( socket )</h3><p>套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同及其间的进程通信。</p>
<h2 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h2><p>线程间的通信目的主要是用于线程同步，所以线程没有像进程通信中的用于数据交换的通信机制。</p>
<p>互斥锁、条件变量、读写锁、信号量、消息队列、事件</p>
<h3 id="使用锁Synchronized"><a href="#使用锁Synchronized" class="headerlink" title="使用锁Synchronized"></a>使用锁Synchronized</h3><h3 id="使用violate修饰全局变量"><a href="#使用violate修饰全局变量" class="headerlink" title="使用violate修饰全局变量"></a>使用violate修饰全局变量</h3><p>violate修饰全局变量，多个线程访问全局变量，保证内存可见性。</p>
<h3 id="管道输入-输出流"><a href="#管道输入-输出流" class="headerlink" title="管道输入/输出流"></a>管道输入/输出流</h3><h3 id="Thread-join"><a href="#Thread-join" class="headerlink" title="Thread.join()"></a>Thread.join()</h3><h2 id="线程与进程间通信"><a href="#线程与进程间通信" class="headerlink" title="线程与进程间通信"></a>线程与进程间通信</h2>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/03/10/操作系统/进程间通信:线程间通信:线程与进程间通信/" data-id="cjtf6o92x004o0fc5vek64na9" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/操作系统/">操作系统</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Java/多线程/线程间的通信" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/10/Java/多线程/线程间的通信/" class="article-date">
  <time datetime="2017-03-10T12:06:13.000Z" itemprop="datePublished">2017-03-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/10/Java/多线程/线程间的通信/">线程间的通信</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="线程间的通信"><a href="#线程间的通信" class="headerlink" title="线程间的通信"></a>线程间的通信</h1><h2 id="volatile-和-synchronized-关键字"><a href="#volatile-和-synchronized-关键字" class="headerlink" title="volatile 和 synchronized 关键字"></a>volatile 和 synchronized 关键字</h2><h3 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h3><p>volatile关键字修饰就是告知程序任何对变量的访问均需要从共享内存中获取，而对它的改变必须同步刷新会共享内存，保证所有线程对变量访问的可见性。</p>
<h3 id="synchronized-关键字"><a href="#synchronized-关键字" class="headerlink" title="synchronized 关键字"></a>synchronized 关键字</h3><p>synchronized关键字可以修饰方法或者以同步块的形式进行使用，确保多个线程在同一时刻，只能有一个线程处于方法或者同步块中，保证了线程对变量访问的可见性和排他性。</p>
<p>在下面的代码中，使用了同步块和同步方法，通过使用javap工具查看生成的class文件信息来分析synchronized关键字的实现细节，示例如下。</p>
        
          <p class="article-more-link">
            <a href="/2017/03/10/Java/多线程/线程间的通信/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/03/10/Java/多线程/线程间的通信/" data-id="cjtf6o96v00ef0fc5p2q7pang" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/多线程/">多线程</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/2/">&laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/15/">15</a><a class="extend next" rel="next" href="/page/4/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Algorithm/">Algorithm</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/FreeMarker/">FreeMarker</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Geek/">Geek</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Job/">Job</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Lucene/">Lucene</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/MapReduce/">MapReduce</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Nutch/">Nutch</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Project/">Project</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python/">Python</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Scala/">Scala</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Scheme/">Scheme</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/kafka/">kafka</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/信息检索/">信息检索</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/健身/">健身</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/操作系统/">操作系统</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据库/">数据库</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据结构/">数据结构</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/王道学习记录/">王道学习记录</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/网络/">网络</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Algorithm/">Algorithm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/FreeMarker/">FreeMarker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Geek/">Geek</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Lucene/">Lucene</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MapReduce/">MapReduce</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Maven/">Maven</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/NIO/">NIO</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Nutch/">Nutch</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Project/">Project</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/">Python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Scala/">Scala</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Scheme/">Scheme</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/kafka/">kafka</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/信息检索/">信息检索</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/健身/">健身</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/多线程/">多线程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/排序算法/">排序算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/操作系统/">操作系统</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据库/">数据库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据结构/">数据结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/框架/">框架</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/王道学习记录/">王道学习记录</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/编程题/">编程题</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/网络/">网络</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/面经/">面经</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/面试笔记/">面试笔记</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Algorithm/" style="font-size: 17px;">Algorithm</a> <a href="/tags/FreeMarker/" style="font-size: 11px;">FreeMarker</a> <a href="/tags/Geek/" style="font-size: 15px;">Geek</a> <a href="/tags/Java/" style="font-size: 20px;">Java</a> <a href="/tags/Linux/" style="font-size: 12px;">Linux</a> <a href="/tags/Lucene/" style="font-size: 11px;">Lucene</a> <a href="/tags/MapReduce/" style="font-size: 14px;">MapReduce</a> <a href="/tags/Maven/" style="font-size: 10px;">Maven</a> <a href="/tags/NIO/" style="font-size: 11px;">NIO</a> <a href="/tags/Nutch/" style="font-size: 19px;">Nutch</a> <a href="/tags/Project/" style="font-size: 11px;">Project</a> <a href="/tags/Python/" style="font-size: 15px;">Python</a> <a href="/tags/Scala/" style="font-size: 11px;">Scala</a> <a href="/tags/Scheme/" style="font-size: 10px;">Scheme</a> <a href="/tags/kafka/" style="font-size: 15px;">kafka</a> <a href="/tags/信息检索/" style="font-size: 14px;">信息检索</a> <a href="/tags/健身/" style="font-size: 10px;">健身</a> <a href="/tags/多线程/" style="font-size: 18px;">多线程</a> <a href="/tags/排序算法/" style="font-size: 19px;">排序算法</a> <a href="/tags/操作系统/" style="font-size: 13px;">操作系统</a> <a href="/tags/数据库/" style="font-size: 18px;">数据库</a> <a href="/tags/数据结构/" style="font-size: 13px;">数据结构</a> <a href="/tags/框架/" style="font-size: 10px;">框架</a> <a href="/tags/王道学习记录/" style="font-size: 13px;">王道学习记录</a> <a href="/tags/编程题/" style="font-size: 16px;">编程题</a> <a href="/tags/网络/" style="font-size: 11px;">网络</a> <a href="/tags/面经/" style="font-size: 14px;">面经</a> <a href="/tags/面试笔记/" style="font-size: 19px;">面试笔记</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">May 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">April 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">March 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">February 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">January 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">December 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">November 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">October 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">September 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">August 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">July 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">June 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">May 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">April 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">March 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/02/">February 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/01/">January 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/12/">December 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/11/">November 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/10/">October 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/09/">September 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/06/">June 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/05/">May 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/04/">April 2015</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/05/22/kafka/kafka详解--性能/">kafka详解--性能</a>
          </li>
        
          <li>
            <a href="/2017/05/22/kafka/Kafka设计解析（一）--Kafka背景及架构介绍/">Kafka设计解析（一）--Kafka背景及架构介绍</a>
          </li>
        
          <li>
            <a href="/2017/04/26/FreeMarker/2017-04-28/">Freemarker入门</a>
          </li>
        
          <li>
            <a href="/2017/04/26/FreeMarker/Freemarker/">Freemarker入门</a>
          </li>
        
          <li>
            <a href="/2017/04/20/Scala/2017-04-24/">Scala学习笔记</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>