<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/page/7/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-数据结构/Trie树:字典树:前缀树" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/09/28/数据结构/Trie树:字典树:前缀树/" class="article-date">
  <time datetime="2016-09-27T17:13:00.000Z" itemprop="datePublished">2016-09-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/数据结构/">数据结构</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/09/28/数据结构/Trie树:字典树:前缀树/">Trie树/字典树/前缀树</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Trie树-字典树-前缀树"><a href="#Trie树-字典树-前缀树" class="headerlink" title="Trie树/字典树/前缀树"></a>Trie树/字典树/前缀树</h1><h2 id="Trie数定义"><a href="#Trie数定义" class="headerlink" title="Trie数定义"></a>Trie数定义</h2><p>Trie树，即字典树，又称单词查找树或键树，是一种树形结构。典型应用是用于统计和排序大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。它的优点是最大限度地减少无谓的字符串比较，查询效率比较高。</p>
<p>Trie的核心思想是空间换时间，利用字符串的公共前缀来降低查询时间的开销以达到提高效率的目的。</p>
<p>它有3个基本性质：</p>
<ol>
<li>根节点不包含字符，除根节点外每一个节点都只包含一个字符。</li>
<li>从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串。</li>
<li>每个节点的所有子节点包含的字符都不相同。</li>
</ol>
<p>Trie树有一些特性：</p>
<ol>
<li>根节点不包含字符，除根节点外每一个节点都只包含一个字符。</li>
<li>从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串。</li>
<li>每个节点的所有子节点包含的字符都不相同。</li>
<li>如果字符的种数为n，则每个结点的出度为n，这也是空间换时间的体现，浪费了很多的空间。</li>
<li>插入查找的复杂度为O(n)，n为字符串长度。</li>
</ol>
<h2 id="Trie树构建"><a href="#Trie树构建" class="headerlink" title="Trie树构建"></a>Trie树构建</h2><p>假如现在给你10万个长度不超过10的单词，对于每一个单词，我们要判断它出没出现过，如果出现了，求第一次出现在第几个位置。对于这个问题，我们该怎么解决呢？</p>
<p>如果我们用最傻的方法，对于每一个单词，我们都要去查找它前面的单词中是否有它。那么这个算法的复杂度就是O(n^2)。显然对于10万的范围难以接受。</p>
<p>换个思路想：</p>
<p>假设我要查询的单词是abcd，那么在它前面的单词中，以b，c，d，f之类开头的显然不必考虑，而只要找以a开头的中是否存在abcd就可以了。<br>同样的，在以a开头中的单词中，我们只要考虑以b作为第二个字母的，一次次缩小范围和提高针对性，这样一个树的模型就渐渐清晰了。<br>即如果现在有b，abc，abd，bcd，abcd，efg，hii 这6个单词，我们可以构建一棵如下图所示的树：</p>
<p><img src="/media/1-1.jpg" alt="1"></p>
<p>如上图所示，对于每一个节点，从根遍历到他的过程就是一个单词，如果这个节点被标记为红色，就表示这个单词存在，否则不存在。</p>
<p>那么，对于一个单词，只要顺着他从根走到对应的节点，再看这个节点是否被标记为红色就可以知道它是否出现过了。把这个节点标记为红色，就相当于插入了这个单词。</p>
<p>这样一来我们查询和插入可以一起完成，所用时间仅仅为单词长度（在这个例子中，便是10）。这就是一棵trie树。</p>
<p>我们可以看到，trie树每一层的节点数是26^i级别的。所以为了节省空间，我们还可以用动态链表，或者用数组来模拟动态。而空间的花费，不会超过单词数×单词长度。</p>
<h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><p>Trie树是简单但实用的数据结构，通常用于实现字典查询。我们做即时响应用户输入的AJAX搜索框时，就是Trie开始。本质上，Trie是一颗存储多个字符串的树。相邻节点间的边代表一个字符，这样树的每条分支代表一则子串，而树的叶节点则代表完整的字符串。和普通树不同的地方是，相同的字符串前缀共享同一条分支。</p>
<p>下面，再举一个例子。给出一组单词，inn, int, at, age, adv, ant, 我们可以得到下面的Trie：2<br><img src="/media/2.gif" alt="2"></p>
<p>可以看出：</p>
<ul>
<li>每条边对应一个字母。</li>
<li>每个节点对应一项前缀。叶节点对应最长前缀，即单词本身。</li>
<li>单词inn与单词int有共同的前缀“in”, 因此他们共享左边的一条分支，root-&gt;i-&gt;in。同理，ate, age, adv, 和ant共享前缀”a”，所以他们共享从根节点到节点”a”的边。</li>
</ul>
<p>查询操纵非常简单。比如要查找int，顺着路径i -&gt; in -&gt; int就找到了。</p>
<p>搭建Trie的基本算法也很简单，无非是逐一把每则单词的每个字母插入Trie。插入前先看前缀是否存在。如果存在，就共享，否则创建对应的节点和边。比如要插入单词add，就有下面几步：</p>
<ol>
<li>考察前缀”a”，发现边a已经存在。于是顺着边a走到节点a。</li>
<li>考察剩下的字符串”dd”的前缀”d”，发现从节点a出发，已经有边d存在。于是顺着边d走到节点ad</li>
<li>考察最后一个字符”d”，这下从节点ad出发没有边d了，于是创建节点ad的子节点add，并把边ad-&gt;add标记为d。</li>
</ol>
<h2 id="问题实例"><a href="#问题实例" class="headerlink" title="问题实例"></a>问题实例</h2><h3 id="1、一个文本文件，大约有一万行，每行一个词，要求统计出其中最频繁出现的前10个词，请给出思想，给出时间复杂度分析"><a href="#1、一个文本文件，大约有一万行，每行一个词，要求统计出其中最频繁出现的前10个词，请给出思想，给出时间复杂度分析" class="headerlink" title="1、一个文本文件，大约有一万行，每行一个词，要求统计出其中最频繁出现的前10个词，请给出思想，给出时间复杂度分析"></a>1、一个文本文件，大约有一万行，每行一个词，要求统计出其中最频繁出现的前10个词，请给出思想，给出时间复杂度分析</h3><p>提示：用trie树统计每个词出现的次数，时间复杂度是<code>O(n*logle)</code>（le表示单词的平均长度），然后是找出出现最频繁的前10个词。当然，也可以用堆来实现，时间复杂度是<code>O(n*log10)</code>。所以总的时间复杂度，是<code>O(n*logle)</code>与<code>O(n*log10)</code>中较大的哪一个。</p>
<h3 id="2、寻找热门查询"><a href="#2、寻找热门查询" class="headerlink" title="2、寻找热门查询"></a>2、寻找热门查询</h3><p>原题：搜索引擎会通过日志文件把用户每次检索使用的所有检索串都记录下来，每个查询串的长度为1-255字节。假设目前有一千万个记录，这些查询串的重复读比较高，虽然总数是1千万，但是如果去除重复和，不超过3百万个。一个查询串的重复度越高，说明查询它的用户越多，也就越热门。请你统计最热门的10个查询串，要求使用的内存不能超过1G。</p>
<p>提示：利用trie树，关键字域存该查询串出现的次数，没有出现为0。最后用10个元素的最小推来对出现频率进行排序。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/09/28/数据结构/Trie树:字典树:前缀树/" data-id="cjtf6o93200500fc5loe5v3bt" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/数据结构/">数据结构</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-数据结构/红黑树详解" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/09/28/数据结构/红黑树详解/" class="article-date">
  <time datetime="2016-09-27T17:13:00.000Z" itemprop="datePublished">2016-09-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/数据结构/">数据结构</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/09/28/数据结构/红黑树详解/">红黑树详解</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="红黑树详解"><a href="#红黑树详解" class="headerlink" title="红黑树详解"></a>红黑树详解</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>R-B Tree，全称是Red-Black Tree，又称为“红黑树”，它一种特殊的二叉查找树。红黑树的每个节点上都有存储位表示节点的颜色，可以是红(Red)或黑(Black)。</p>
<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ol>
<li>每个节点或者是黑色，或者是红色。</li>
<li>根节点是黑色。</li>
<li>每个叶子节点（NIL）是黑色。</li>
<li>如果一个节点是红色的，则它的子节点必须是黑色的。</li>
<li>从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。(确保没有一条路径会比其他路径长出俩倍)</li>
</ol>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>主要是用它来存储有序的数据，它的时间复杂度是O(logn)，效率非常之高。</p>
<blockquote>
<p>Java集合中的TreeSet和TreeMap，C++ STL中的set、map，以及Linux虚拟内存的管理，都是通过红黑树去实现的。</p>
</blockquote>
<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><p>### </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/09/28/数据结构/红黑树详解/" data-id="cjtf6o93400550fc5fb0wkbqt" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/数据结构/">数据结构</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Algorithm/排序算法/排序算法之计数排序" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/09/27/Algorithm/排序算法/排序算法之计数排序/" class="article-date">
  <time datetime="2016-09-27T03:11:11.000Z" itemprop="datePublished">2016-09-27</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Algorithm/">Algorithm</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/09/27/Algorithm/排序算法/排序算法之计数排序/">排序算法之计数排序</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="排序算法之计数排序"><a href="#排序算法之计数排序" class="headerlink" title="排序算法之计数排序"></a>排序算法之计数排序</h1><p>待排序的数要满足一定的范围的整数，比如 [0~100]，[10000~19999] 这样的数据，而且计数排序需要比较多的辅助空间，仅适用于数据比较集中的情况。</p>
<p>基本思想是：对每一个输入的元素arr[i]，确定小于 arr[i] 的元素个数。</p>
<p>需要三个数组:</p>
<ul>
<li>待排序数组 int[] arr = new int[]{4,3,6,3,5,1};</li>
<li>辅助计数数组 int[] help = new int[max - min + 1]; //该数组大小为待排序数组中的最大值减最小值+1</li>
<li>输出数组 int[] res = new int[arr.length];</li>
</ul>
<p>步骤：</p>
<ol>
<li>建一个长度为K+1的的数组C，里面的每一个元素初始都置为0(Java里面默认就是0)。</li>
<li>遍历待排序的数组，计算其中的每一个元素出现的次数，比如一个key为i的元素出现了3次，那么C[i]=3。</li>
<li>累加C数组，获得元素的排位，从0开始遍历C, C[i+1]=C[i]+C[i-1]</li>
<li>建一个临时数组T，长度与待排序数组一样。从数组末尾遍历待排序数组，把元素都安排到T里面，直接从C里面就可以得到元素的具体位置， 不过记得每处理过一个元素之后都要把C里面对应位置的计数减1。</li>
</ol>
<p>计数排序的时间复杂度也是O(n)，稳定排序算法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public class CountSort &#123;</span><br><span class="line"></span><br><span class="line">    public static void countSort(int[] arr) &#123;</span><br><span class="line">        if(arr == null || arr.length == 0)</span><br><span class="line">            return ;</span><br><span class="line"></span><br><span class="line">        int max = max(arr);</span><br><span class="line"></span><br><span class="line">        int[] count = new int[max+1];</span><br><span class="line">        Arrays.fill(count, 0);</span><br><span class="line"></span><br><span class="line">        for(int i=0; i&lt;arr.length; i++) &#123;</span><br><span class="line">            count[arr[i]] ++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int k = 0;</span><br><span class="line">        for(int i=0; i&lt;=max; i++) &#123;</span><br><span class="line">            for(int j=0; j&lt;count[i]; j++) &#123;</span><br><span class="line">                arr[k++] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static int max(int[] arr) &#123;</span><br><span class="line">        int max = Integer.MIN_VALUE;</span><br><span class="line">        for(int ele : arr) &#123;</span><br><span class="line">            if(ele &gt; max)</span><br><span class="line">                max = ele;</span><br><span class="line">        &#125;</span><br><span class="line">        return max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/09/27/Algorithm/排序算法/排序算法之计数排序/" data-id="cjtf6o96400cr0fc5b9n34s38" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/排序算法/">排序算法</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Algorithm/排序算法/排序算法之归并排序" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/09/26/Algorithm/排序算法/排序算法之归并排序/" class="article-date">
  <time datetime="2016-09-26T03:11:11.000Z" itemprop="datePublished">2016-09-26</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Algorithm/">Algorithm</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/09/26/Algorithm/排序算法/排序算法之归并排序/">排序算法之归并排序</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="排序算法之归并排序"><a href="#排序算法之归并排序" class="headerlink" title="排序算法之归并排序"></a>排序算法之归并排序</h1><p>归并（Merge）排序法是将两个（或两个以上）有序表合并成一个新的有序表，即把待排序序列分为若干个子序列，每个子序列是有序的。然后再把有序子序列合并为整体有序序列。</p>
<p>归并排序的时间复杂度也是O(nlogn)，稳定排序方式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">public class MergeSort &#123;</span><br><span class="line">    public static void mergeSort(int [] array) &#123;</span><br><span class="line">        divide(array, 0, array.length-1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void divide(int [] array, int left, int right) &#123;</span><br><span class="line">        if (left == right) &#123;</span><br><span class="line">            return ;</span><br><span class="line">        &#125;</span><br><span class="line">        int middle = (left + right) / 2;</span><br><span class="line">        divide(array, left, middle);</span><br><span class="line">        divide(array, middle+1, right);</span><br><span class="line">        merge(array, left, middle, right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void merge(int [] array, int left, int middle, int right) &#123;</span><br><span class="line">        //[left, middle][middle+1, right]</span><br><span class="line">        int[] tempArray = new int[right - left + 1];</span><br><span class="line"></span><br><span class="line">        int i = left;</span><br><span class="line">        int j = middle + 1;</span><br><span class="line">        int k = 0;</span><br><span class="line"></span><br><span class="line">        //把较小的数先移到tempArray</span><br><span class="line">        while (i &lt;= middle &amp;&amp; j &lt;= right) &#123;</span><br><span class="line">            if (array[i] &lt; array[j]) &#123;</span><br><span class="line">                tempArray[k++] = array[i++];</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                tempArray[k++] = array[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //把左边或者右边剩余数组移入新数组</span><br><span class="line">        while(i &lt; middle)</span><br><span class="line">            tempArray[k++] = array[i++];</span><br><span class="line">        while(j &lt; right)</span><br><span class="line">            tempArray[k++] = array[j++];</span><br><span class="line"></span><br><span class="line">        //一次遍历，新数组覆盖原数组</span><br><span class="line">        for (int m = 0; m &lt; tempArray.length; m++) &#123;</span><br><span class="line">            array[m + left] = tempArray[m];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/09/26/Algorithm/排序算法/排序算法之归并排序/" data-id="cjtf6o95z00cf0fc5d276e7iq" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/排序算法/">排序算法</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Algorithm/排序算法/排序算法之希尔排序" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/09/25/Algorithm/排序算法/排序算法之希尔排序/" class="article-date">
  <time datetime="2016-09-25T09:30:11.000Z" itemprop="datePublished">2016-09-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Algorithm/">Algorithm</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/09/25/Algorithm/排序算法/排序算法之希尔排序/">排序算法之希尔排序</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="排序算法之希尔排序"><a href="#排序算法之希尔排序" class="headerlink" title="排序算法之希尔排序"></a>排序算法之希尔排序</h1><p>希尔排序（缩小增量插入排序）<br>先将整个待排记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录基本有序时再对全体记录进行一次直接插入排序。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class ShellSort &#123;</span><br><span class="line">	public static void shellSort(int[] array) &#123;</span><br><span class="line">		if (array == null || array.length == 0) </span><br><span class="line">			return ;</span><br><span class="line">		//每次将步长缩短为原来的一半</span><br><span class="line">		for (int increment = array.length / 2; increment &gt; 0; increment /= 2) &#123;</span><br><span class="line">			for (int i = increment; i &lt; array.length; i++) &#123;</span><br><span class="line">				int temp = array[i];</span><br><span class="line">				for (int j = i; (j &gt;= increment) &amp;&amp; (temp &lt; array[j - increment]); j -= increment) &#123;</span><br><span class="line">					array[j] = array[j-increment];</span><br><span class="line">				&#125;</span><br><span class="line">				array[j] = temp;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/09/25/Algorithm/排序算法/排序算法之希尔排序/" data-id="cjtf6o95x00c90fc5g8itrns2" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/排序算法/">排序算法</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Algorithm/排序算法/排序算法之堆排序" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/09/24/Algorithm/排序算法/排序算法之堆排序/" class="article-date">
  <time datetime="2016-09-23T17:13:00.000Z" itemprop="datePublished">2016-09-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Algorithm/">Algorithm</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/09/24/Algorithm/排序算法/排序算法之堆排序/">排序算法之堆排序</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="排序算法之堆排序"><a href="#排序算法之堆排序" class="headerlink" title="排序算法之堆排序"></a>排序算法之堆排序</h1><p>堆排序是一种树形选择排序方法，它的特点是：在排序的过程中，将array[0，…，n-1]看成是一颗完全二叉树的顺序存储结构，利用完全二叉树中双亲节点和孩子结点之间的内在关系，在当前无序区中选择关键字最大（最小）的元素。</p>
<ol>
<li>若array[0，…，n-1]表示一颗完全二叉树的顺序存储模式，则双亲节点指针和孩子结点指针之间的内在关系如下<blockquote>
<p>任意一节点指针 i：<br> 父节点：i==0 ? null : (i-1)/2<br> 左孩子：2<em>i + 1<br> 右孩子：2</em>i + 2</p>
</blockquote>
</li>
<li><p>堆的定义：n个关键字序列array[0，…，n-1]，当且仅当满足下列要求：(0 &lt;= i &lt;= (n-1)/2)</p>
<ul>
<li>array[i] &lt;= array[2<em>i + 1] 且 array[i] &lt;= array[2</em>i + 2]； 称为小根堆；</li>
<li>array[i] &gt;= array[2<em>i + 1] 且 array[i] &gt;= array[2</em>i + 2]； 称为大根堆；</li>
</ul>
</li>
<li><p>建立大根堆：</p>
<p> n个节点的完全二叉树array[0，…，n-1]，最后一个节点n-1是第(n-1-1)/2个节点的孩子。对第(n-1-1)/2个节点为根的子树调整，使该子树称为堆。</p>
<p> 对于大根堆，调整方法为：若【根节点的关键字】小于【左右子女中关键字较大者】，则交换。</p>
<p> 之后向前依次对各节点（(n-2)/2 - 1）~ 0为根的子树进行调整，看该节点值是否大于其左右子节点的值，若不是，将左右子节点中较大值与之交换，交换后可能会破坏下一级堆，于是继续采用上述方法构建下一级的堆，直到以该节点为根的子树构成堆为止。</p>
<p> 反复利用上述调整堆的方法建堆，直到根节点。</p>
</li>
</ol>
<p>4.堆排序：（大根堆）<br>　　1. 将存放在array[0，…，n-1]中的n个元素建成初始堆；<br>　　2. 将堆顶元素与堆底元素进行交换，则序列的最大值即已放到正确的位置；<br>　　3. 但此时堆被破坏，将堆顶元素向下调整使其继续保持大根堆的性质，再重复第②③步，直到堆中仅剩下一个元素为止。</p>
<p>堆排序算法的性能分析：</p>
<ul>
<li>空间复杂度:O(1)；</li>
<li>时间复杂度:建堆：O(n)，每次调整o(log n)，故最好、最坏、平均情况下：o(n*logn);</li>
<li>稳定性：不稳定</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将元素array[k]自上往下逐步调整树形结构</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapAdjust</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> k, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = array[k];</span><br><span class="line">        <span class="comment">//i为初始化为节点k的左孩子，沿节点较大的子节点向下调整</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span> * k + <span class="number">1</span>; i &lt; length -<span class="number">1</span>  ; i = <span class="number">2</span> * i + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">//左右孩子的节点分别为2*i+1,2*i+2</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//选择出左右孩子较小的下标</span></span><br><span class="line">            <span class="keyword">if</span>(i &lt; length &amp;&amp; array[i] &lt; array[i+<span class="number">1</span>]) &#123;</span><br><span class="line">                i ++; <span class="comment">//如果节点的右孩子&gt;左孩子，则取右孩子节点的下标</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(temp &gt;= array[i]) &#123; <span class="comment">//根节点 &gt;=左右子女中关键字较大者，保持稳定</span></span><br><span class="line">                <span class="keyword">break</span>; </span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                array[k] = array[i]; <span class="comment">//将子节点上移</span></span><br><span class="line">                k = i; <span class="comment">//【关键】修改k值，以便继续向下调整</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        array[k] = temp; <span class="comment">//插入正确的位置</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(array == <span class="keyword">null</span> || array.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        <span class="comment">//建堆：从最后一个节点array.length-1的父节点（array.length-1-1）/2开始，直到根节点0，反复调整堆</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = (array.length - <span class="number">2</span>) / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            heapAdjust(array, i, array.length);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//排序过程</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=array.length-<span class="number">1</span>; i&gt;<span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = array[<span class="number">0</span>];</span><br><span class="line">            array[<span class="number">0</span>] = array[i];</span><br><span class="line">            array[i] = temp;</span><br><span class="line">            heapAdjust(array, <span class="number">0</span>, i);<span class="comment">//整理，将剩余的元素整理成堆</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/09/24/Algorithm/排序算法/排序算法之堆排序/" data-id="cjtf6o95v00c30fc5so67dmwa" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/排序算法/">排序算法</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Algorithm/排序算法/排序算法之快速排序" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/09/23/Algorithm/排序算法/排序算法之快速排序/" class="article-date">
  <time datetime="2016-09-23T03:11:11.000Z" itemprop="datePublished">2016-09-23</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Algorithm/">Algorithm</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/09/23/Algorithm/排序算法/排序算法之快速排序/">排序算法之快速排序</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="排序算法之快速排序"><a href="#排序算法之快速排序" class="headerlink" title="排序算法之快速排序"></a>排序算法之快速排序</h1><p>基于分治的思想，是冒泡排序的改进型。</p>
<p>首先在数组中选择一个基准点（该基准点的选取可能影响快速排序的效率，后面讲解选取的方法），然后分别从数组的两端扫描数组，设两个指示标志（lo指向起始位置，hi指向末尾)，</p>
<ol>
<li>首先从后半部分开始，如果发现有元素比该基准点的值小，就交换lo和hi位置的值</li>
<li>然后从前半部分开始扫秒，发现有元素大于基准点的值，就交换lo和hi位置的值，如此往复循环</li>
<li>直到lo&gt;=hi,然后把基准点的值放到hi这个位置。一次排序就完成了</li>
<li>以后采用递归的方式分别对前半部分和后半部分排序，当前半部分和后半部分均有序时该数组就自然有序了</li>
</ol>
<p>快速排序的时间复杂度也是O(nlogn)</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public class QuickSort &#123;</span><br><span class="line">	//查找基准点所在位置，并划分为左右两半</span><br><span class="line">	public static int partition(int [] array, int low, int high) &#123;</span><br><span class="line">		int key = array[low];//固定基准点的划分方式,数组第一个数</span><br><span class="line">		while(low &lt; high) &#123;</span><br><span class="line">			while(low &lt; high &amp;&amp; array[high] &gt;= key) //从后向前扫描，找到小于key的值</span><br><span class="line">				high --;</span><br><span class="line">			array[low] = array[high];</span><br><span class="line">			while(low &lt; high &amp;&amp; array[low] &lt;= key)  //从前向后扫描，找到大于key的值</span><br><span class="line">				low ++;</span><br><span class="line">			array[high] = array[low];</span><br><span class="line">		&#125;</span><br><span class="line">		array[high] = key;//跳出循环后low==high</span><br><span class="line">		return high;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	//递归形式的分治排序算法</span><br><span class="line">	public static void quickSort(int[] array, int low, int high) &#123;</span><br><span class="line">		if(low &gt; high)</span><br><span class="line">			return ;</span><br><span class="line">		int keyIndex = partition(array, low, high);</span><br><span class="line">		quickSort(array, low, keyIndex-1);</span><br><span class="line">		quickSort(array, keyIndex+1, high);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	//快速排序调用</span><br><span class="line">	public static void quick(int[] array) &#123;</span><br><span class="line">		if (array != null &amp;&amp; array.length != 0) &#123;</span><br><span class="line">			quickSort(array, 0, array.length-1);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/09/23/Algorithm/排序算法/排序算法之快速排序/" data-id="cjtf6o96000ch0fc5riuvg0ej" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/排序算法/">排序算法</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Algorithm/排序算法/排序算法之插入排序" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/09/22/Algorithm/排序算法/排序算法之插入排序/" class="article-date">
  <time datetime="2016-09-22T09:11:00.000Z" itemprop="datePublished">2016-09-22</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Algorithm/">Algorithm</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/09/22/Algorithm/排序算法/排序算法之插入排序/">排序算法之插入排序</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="排序算法之插入排序"><a href="#排序算法之插入排序" class="headerlink" title="排序算法之插入排序"></a>排序算法之插入排序</h1><ol>
<li>从第一个元素开始，该元素可以认为已经被排序</li>
<li>取出下一个元素，在已经排序的元素序列中从后向前扫描 </li>
<li>如果该元素（已排序）大于新元素，将该元素移到下一位置  </li>
<li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置，将新元素插入到该位置中  </li>
</ol>
<p>简单插入排序的时间复杂度也是O(n^2)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class InsertSort &#123;</span><br><span class="line">	public static void insertSort(int[] array) &#123;</span><br><span class="line">		if(array == null || array.length == 0)</span><br><span class="line">			return ;</span><br><span class="line">		for (int i = 1; i &lt; array.length; i++) &#123;</span><br><span class="line">			int j = i;</span><br><span class="line">			int temp = array[i];</span><br><span class="line">			for(int j = i; (j &gt; 0) &amp;&amp; (temp &lt; array[j-1]); j--) //比较并将大于target的数后移</span><br><span class="line">				array[j] = array[j-1];</span><br><span class="line">			//将target插入合适位置</span><br><span class="line">			array[j] = temp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/09/22/Algorithm/排序算法/排序算法之插入排序/" data-id="cjtf6o95y00cb0fc5uzmptuao" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/排序算法/">排序算法</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Algorithm/排序算法/排序算法之选择排序" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/09/21/Algorithm/排序算法/排序算法之选择排序/" class="article-date">
  <time datetime="2016-09-21T09:11:00.000Z" itemprop="datePublished">2016-09-21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Algorithm/">Algorithm</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/09/21/Algorithm/排序算法/排序算法之选择排序/">排序算法之选择排序</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="排序算法之选择排序"><a href="#排序算法之选择排序" class="headerlink" title="排序算法之选择排序"></a>排序算法之选择排序</h1><p>在未排序序列中找到最小元素，并与待排序列的首位进行交换。<br>选择排序可以看成冒泡排序的优化，因为其目的相同，只是选择排序只有在确定了最小数的前提下才进行交换，大大减少了交换的次数。</p>
<p>选择排序的时间复杂度为O(n^2)  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class SelectSort &#123;</span><br><span class="line">	public static void selectSort(int [] arr) &#123;</span><br><span class="line">		if(arr.length == 0 || arr == null)</span><br><span class="line">			return ;</span><br><span class="line">		int minIndex = 0;</span><br><span class="line">		for(int i = 0; i &lt; arr.length-1; i++) &#123;</span><br><span class="line">			minIndex = i;</span><br><span class="line">			for (int j = i+1; j &lt; arr.length-i-1; j++) &#123;</span><br><span class="line">				if (arr[minIndex] &gt; arr[j])</span><br><span class="line">					minIndex = j;</span><br><span class="line">			&#125;</span><br><span class="line">			if(minIndex != i)</span><br><span class="line">				swap(arr, i, minIndex);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void swap(int[] arr, int a, int b) &#123;</span><br><span class="line">		int tmp = arr[a];</span><br><span class="line">		arr[a] = arr[b];</span><br><span class="line">		arr[b] = tmp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/09/21/Algorithm/排序算法/排序算法之选择排序/" data-id="cjtf6o96700d10fc56x51popl" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/排序算法/">排序算法</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Java/框架学习/SpringMVC/SpringMVC学习" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/09/21/Java/框架学习/SpringMVC/SpringMVC学习/" class="article-date">
  <time datetime="2016-09-21T08:06:13.000Z" itemprop="datePublished">2016-09-21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/09/21/Java/框架学习/SpringMVC/SpringMVC学习/">SpringMVC学习</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="SpringMVC学习"><a href="#SpringMVC学习" class="headerlink" title="SpringMVC学习"></a>SpringMVC学习</h1><p>什么是SpringMVC？</p>
        
          <p class="article-more-link">
            <a href="/2016/09/21/Java/框架学习/SpringMVC/SpringMVC学习/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/09/21/Java/框架学习/SpringMVC/SpringMVC学习/" data-id="cjtf6o97300ev0fc510lw0bca" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/框架/">框架</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/6/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><a class="page-number" href="/page/9/">9</a><span class="space">&hellip;</span><a class="page-number" href="/page/15/">15</a><a class="extend next" rel="next" href="/page/8/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Algorithm/">Algorithm</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/FreeMarker/">FreeMarker</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Geek/">Geek</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Job/">Job</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Lucene/">Lucene</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/MapReduce/">MapReduce</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Nutch/">Nutch</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Project/">Project</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python/">Python</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Scala/">Scala</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Scheme/">Scheme</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/kafka/">kafka</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/信息检索/">信息检索</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/健身/">健身</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/操作系统/">操作系统</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据库/">数据库</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据结构/">数据结构</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/王道学习记录/">王道学习记录</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/网络/">网络</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Algorithm/">Algorithm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/FreeMarker/">FreeMarker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Geek/">Geek</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Lucene/">Lucene</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MapReduce/">MapReduce</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Maven/">Maven</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/NIO/">NIO</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Nutch/">Nutch</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Project/">Project</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/">Python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Scala/">Scala</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Scheme/">Scheme</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/kafka/">kafka</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/信息检索/">信息检索</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/健身/">健身</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/多线程/">多线程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/排序算法/">排序算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/操作系统/">操作系统</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据库/">数据库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据结构/">数据结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/框架/">框架</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/王道学习记录/">王道学习记录</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/编程题/">编程题</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/网络/">网络</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/面经/">面经</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/面试笔记/">面试笔记</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Algorithm/" style="font-size: 17px;">Algorithm</a> <a href="/tags/FreeMarker/" style="font-size: 11px;">FreeMarker</a> <a href="/tags/Geek/" style="font-size: 15px;">Geek</a> <a href="/tags/Java/" style="font-size: 20px;">Java</a> <a href="/tags/Linux/" style="font-size: 12px;">Linux</a> <a href="/tags/Lucene/" style="font-size: 11px;">Lucene</a> <a href="/tags/MapReduce/" style="font-size: 14px;">MapReduce</a> <a href="/tags/Maven/" style="font-size: 10px;">Maven</a> <a href="/tags/NIO/" style="font-size: 11px;">NIO</a> <a href="/tags/Nutch/" style="font-size: 19px;">Nutch</a> <a href="/tags/Project/" style="font-size: 11px;">Project</a> <a href="/tags/Python/" style="font-size: 15px;">Python</a> <a href="/tags/Scala/" style="font-size: 11px;">Scala</a> <a href="/tags/Scheme/" style="font-size: 10px;">Scheme</a> <a href="/tags/kafka/" style="font-size: 15px;">kafka</a> <a href="/tags/信息检索/" style="font-size: 14px;">信息检索</a> <a href="/tags/健身/" style="font-size: 10px;">健身</a> <a href="/tags/多线程/" style="font-size: 18px;">多线程</a> <a href="/tags/排序算法/" style="font-size: 19px;">排序算法</a> <a href="/tags/操作系统/" style="font-size: 13px;">操作系统</a> <a href="/tags/数据库/" style="font-size: 18px;">数据库</a> <a href="/tags/数据结构/" style="font-size: 13px;">数据结构</a> <a href="/tags/框架/" style="font-size: 10px;">框架</a> <a href="/tags/王道学习记录/" style="font-size: 13px;">王道学习记录</a> <a href="/tags/编程题/" style="font-size: 16px;">编程题</a> <a href="/tags/网络/" style="font-size: 11px;">网络</a> <a href="/tags/面经/" style="font-size: 14px;">面经</a> <a href="/tags/面试笔记/" style="font-size: 19px;">面试笔记</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">May 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">April 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">March 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">February 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">January 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">December 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">November 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">October 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">September 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">August 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">July 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">June 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">May 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">April 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">March 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/02/">February 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/01/">January 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/12/">December 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/11/">November 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/10/">October 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/09/">September 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/06/">June 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/05/">May 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/04/">April 2015</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/05/22/kafka/kafka详解--性能/">kafka详解--性能</a>
          </li>
        
          <li>
            <a href="/2017/05/22/kafka/Kafka设计解析（一）--Kafka背景及架构介绍/">Kafka设计解析（一）--Kafka背景及架构介绍</a>
          </li>
        
          <li>
            <a href="/2017/04/26/FreeMarker/2017-04-28/">Freemarker入门</a>
          </li>
        
          <li>
            <a href="/2017/04/26/FreeMarker/Freemarker/">Freemarker入门</a>
          </li>
        
          <li>
            <a href="/2017/04/20/Scala/2017-04-24/">Scala学习笔记</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>